package main

import (
	"fmt"
	"encoding/json"
	"strconv"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

type SimpleChaincode struct {
}


type Donor struct {
	ObjectType     string      `json:"docType"` // field for couchdb
	Id     string     `json:"id"`
	Name     string     `json:"name"`
	Phone     string	`json:"phone"`
	Credit     int     `json:"credit"`
	Assets_array []string
}


type Asset struct {
	ObjectType     string      `json:"docType"` // field for couchdb
	Id     string     `json:"id"`
	Name  string
	DonorId     string     `json:"donorid"`
	NPOId string
	Owner_history []OwnerRelation `json:"owner"`
	Status     string     `json:"status"`
	ProductType     string     `json:"producttype"`
	Picture     string     `json:"pichash"` // generated by hashing algorithm

}

type NPO struct {
	ObjectType     string      `json:"docType"` // field for couchdb
	Id     string     `json:"id"`
	Name     string     `json:"name"`
	Assets_array []string
	Needs []Need
}

type Recipient struct {
	ObjectType     string      `json:"docType"` // field for couchdb
	Id     string	`json:"id"`
	Name     string     `json:"name"`
	Types string
	Asset_array []string
}


type OwnerRelation struct {
	Id         string `json:"id"`
	Username   string `json:"username"`    //this is mostly cosmetic/handy, the real relation is by Id not Username
	User_type   string `json:"user_type"`     //this is mostly cosmetic/handy, the real relation is by Id not Company
}


// Donation needs from NPO
type Need struct {
	ProductType string `json:"producttype"`
	Name string
	Total_count int `json:"count"`
	Current_count int `json:"count"`
	status string
}

// ============================================================================================================================
// Main
// ============================================================================================================================
func main() {
	err := shim.Start(new(SimpleChaincode))
	if err != nil {
		fmt.Printf("Error starting Simple chaincode - %s", err)
	}
}


// Init function
// Activate when instantiating
func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {
	fmt.Println("Marbles Is Starting Up")
	funcName, args := stub.GetFunctionAndParameters()
	var err error
	txId := stub.GetTxID()

	fmt.Println("Init() is running")
	fmt.Println("Transaction ID:", txId)
	fmt.Println("  GetFunctionAndParameters() function:", funcName)
	fmt.Println("  GetFunctionAndParameters() args count:", len(args))
	fmt.Println("  GetFunctionAndParameters() args found:", args)


	// showing the alternative argument shim function
	alt := stub.GetStringArgs()
	fmt.Println("  GetStringArgs() args count:", len(alt))
	fmt.Println("  GetStringArgs() args found:", alt)

	// store compatible marbles application version
	err = stub.PutState("marbles_ui", []byte("0.0.1"))
	if err != nil {
		return shim.Error(err.Error())
	}

	fmt.Println("Ready for action")                          //self-test pass
	return shim.Success(nil)
}

// ============================================================================================================================
// Invoke - Our entry point for Invocations
// ============================================================================================================================
func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
	function, args := stub.GetFunctionAndParameters()
	fmt.Println(" ")
	fmt.Println("starting invoke, for - " + function)
	fmt.Println("starting invoke, for - " + args[0])

	if function == "query"{
		return t.query(stub, args)
	} else if function == "enroll_donor"{
		return t.enroll_donor(stub, args)
	} else if function == "enroll_npo" {
		return t.enroll_npo(stub, args)
	} else if function == "propose_asset" {
		return t.propose_asset(stub, args)
	} else if function == "approve_asset" {
		return t.approve_asset(stub, args)
	} else if function == "delete_asset" {
		return t.delete_asset(stub, args)
	} else if function == "enroll_recipient" {
		return t.enroll_recipient(stub, args)
	} else if function == "borrow_asset" {
		return t.borrow_asset(stub, args)
	} else if function == "give_asset" {
		return t.give_asset(stub, args)
	} else if function == "get_back_asset" {
		return t.get_back_asset(stub, args)
	}

	// error out
	fmt.Println("Received unknown invoke function name - " + function)
	return shim.Error("Received unknown invoke function name - '" + function + "'")
}

func (t *SimpleChaincode) enroll_donor(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var temp_donor Donor  // Entities
	var err error

	if len(args) != 3 {
		return shim.Error("Incorrect number of arguments. Expecting 3")
	}

	temp_donor.ObjectType = "Donor"
	temp_donor.Id = args[0] // d0~d999999999
	temp_donor.Name = args[1]
	temp_donor.Phone = args[2]
	temp_donor.Credit = 0
	temp_donor.Assets_array = []string{}

	fmt.Println(temp_donor)

	donorAsBytes, _ := json.Marshal(temp_donor)
	fmt.Println("writing donor to state")
	fmt.Println(string(donorAsBytes))

	err = stub.PutState(temp_donor.Id, donorAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store donor")
		return shim.Error(err.Error())
	}

	return shim.Success(nil)
}

func (t *SimpleChaincode) enroll_npo(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var temp_NPO NPO  // Entities
	var err error

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}


	temp_NPO.ObjectType = "NPO"
	temp_NPO.Id = args[0]
	temp_NPO.Name = args[1]
	temp_NPO.Assets_array = []string{}
	temp_NPO.Needs = []Need{}

	fmt.Println(temp_NPO)

	NPOAsBytes, _ := json.Marshal(temp_NPO)
	fmt.Println("writing NPO information to ledger")
	fmt.Println(string(NPOAsBytes))

	err = stub.PutState(temp_NPO.Id, NPOAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store NPO")
		return shim.Error(err.Error())
	}

	return shim.Success(nil)
}

func (t *SimpleChaincode) enroll_recipient(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var temp_rec Recipient  // Entities
	var err error

	if len(args) != 3 {
		return shim.Error("Incorrect number of arguments. Expecting 3")
	}

	temp_rec.ObjectType = "Recipient"
	temp_rec.Id = args[0]
	temp_rec.Name = args[1]
	temp_rec.Types = args[2]
	temp_rec.Asset_array = []string{}

	fmt.Println(temp_rec)

	RecAsBytes, _ := json.Marshal(temp_rec)
	fmt.Println("writing Recipient information to ledger")
	fmt.Println(string(RecAsBytes))

	err = stub.PutState(temp_rec.Id, RecAsBytes)  //store owner by its Id
	if err != nil {
		fmt.Println("Could not store Recipient")
		return shim.Error(err.Error())
	}

	return shim.Success(nil)
}

func (t *SimpleChaincode) enroll_needs(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var err error

	if len(args) != 4 {
		return shim.Error("Incorrect number of arguments. Expecting 4")
	}

	var temp_npo NPO
	temp_npo_id := args[0]
	temp_npo_by_byte, err := stub.GetState(temp_npo_id)
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get Asset state for\"}"
		return shim.Error(jsonResp)
	}
	json.Unmarshal(temp_npo_by_byte, &temp_npo)

	fmt.Println(temp_npo)

	var temp_need Need

	temp_need.Name = args[1]
	temp_need.ProductType = args[2]
	temp_need.Total_count,_ = strconv.Atoi(args[3])
	temp_need.Current_count = 0
	temp_need.status = "I"

	fmt.Println(temp_need)

	temp_npo.Needs = append(temp_npo.Needs, temp_need)

	NPOAsBytes, _ := json.Marshal(temp_npo)
	fmt.Println("writing NPO information to ledger")
	fmt.Println(string(NPOAsBytes))

	err = stub.PutState(temp_npo.Id, NPOAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store NPO")
		return shim.Error(err.Error())
	}

	return shim.Success(nil)
}

func (t *SimpleChaincode) propose_asset(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var temp_asset Asset  // Entities
	var err error

	if len(args) != 6 {
		return shim.Error("Incorrect number of arguments. Expecting 6")
	}

	temp_asset.ObjectType = "Asset"
	temp_asset.Id = args[0]
	temp_asset.Name = args[1]

	var temp_donor Donor
	temp_donor_by_byte, err := stub.GetState(args[2])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get donor state\"}"
		return shim.Error(jsonResp)
	}

	if temp_donor_by_byte == nil {
		jsonResp := "{\"Error\":\"Nil amount for \"}"
		return shim.Error(jsonResp)
	}

	json.Unmarshal(temp_donor_by_byte, &temp_donor)

	temp_asset.DonorId = temp_donor.Id

	var temp_npo NPO
	temp_npo_by_byte, err := stub.GetState(args[3])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get NPO state for \"}"
		return shim.Error(jsonResp)
	}

	if temp_donor_by_byte == nil {
		jsonResp := "{\"Error\":\"Nil amount for NPO state\"}"
		return shim.Error(jsonResp)
	}
	json.Unmarshal(temp_npo_by_byte, &temp_npo)

	temp_asset.NPOId = temp_npo.Id
	temp_asset.Owner_history = []OwnerRelation{}
	temp_asset.Status = "P"
	temp_asset.ProductType = args[4]
	temp_asset.Picture = args[5]

	fmt.Println(temp_asset)

	AssetAsBytes, _ := json.Marshal(temp_asset)
	fmt.Println("writing Asset information to ledger")
	fmt.Println(string(AssetAsBytes))

	err = stub.PutState(temp_asset.Id, AssetAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store Asset")
		return shim.Error(err.Error())
	}


	temp_donor.Assets_array = append(temp_donor.Assets_array, temp_asset.Id)
	fmt.Println(temp_donor)
	DonorAsBytes, _ := json.Marshal(temp_donor)
	fmt.Println("Updating donor information to ledger")
	fmt.Println(string(DonorAsBytes))

	err = stub.PutState(temp_donor.Id, DonorAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not update donor")
		return shim.Error(err.Error())
	}

	temp_npo.Assets_array = append(temp_npo.Assets_array, temp_asset.Id)
	fmt.Println(temp_npo)
	NpoAsBytes, _ := json.Marshal(temp_npo)
	fmt.Println("Updating npo information to ledger")
	fmt.Println(string(NpoAsBytes))

	err = stub.PutState(temp_npo.Id,  NpoAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not update NPO")
		return shim.Error(err.Error())
	}

	return shim.Success(nil)
}

func (t *SimpleChaincode) approve_asset(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var err error

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	var temp_asset Asset
	temp_asset_by_byte, err := stub.GetState(args[0])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get Asset state\"}"
		return shim.Error(jsonResp)
	}
	json.Unmarshal(temp_asset_by_byte, &temp_asset)

	fmt.Println(temp_asset.NPOId)
	if temp_asset.NPOId != args[1]{
		jsonResp := "{\"Error\":\"Asset is not owned by given NPO\"}"
		return shim.Error(jsonResp)
	}

	var temp_npo NPO
	temp_npo_by_byte, err := stub.GetState(temp_asset.NPOId)
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get npo state \"}"
		return shim.Error(jsonResp)
	}
	json.Unmarshal(temp_npo_by_byte, &temp_npo)

	fmt.Println(temp_npo)

	check := false
	for _, v := range temp_npo.Needs {
		fmt.Println(temp_asset.Name)
		fmt.Println(v.Name)
		if v.Name == temp_asset.Name {
			v.Current_count = v.Current_count + 1
			if v.Current_count == v.Total_count{
				v.status = "C"
			}
			check = true
			break
		}
	}


	temp_asset.Status = "A"

	fmt.Println(temp_asset)

	AssetAsBytes, _ := json.Marshal(temp_asset)
	fmt.Println("writing Asset information to ledger")
	fmt.Println(string(AssetAsBytes))

	err = stub.PutState(temp_asset.Id, AssetAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store Asset")
		return shim.Error(err.Error())
	}

	if check == true {
		var temp_donor Donor
		temp_donor_id := temp_asset.DonorId
		temp_donor_by_byte, err := stub.GetState(temp_donor_id)
		if err != nil {
			jsonResp := "{\"Error\":\"Failed to get Donor state\"}"
			return shim.Error(jsonResp)
		}
		json.Unmarshal(temp_donor_by_byte, &temp_donor)
		temp_donor.Credit = temp_donor.Credit + 1
		fmt.Println(temp_donor)

		DonorAsBytes, _ := json.Marshal(temp_donor)
		fmt.Println("writing Donor information to ledger")
		fmt.Println(string(DonorAsBytes))

		err = stub.PutState(temp_donor.Id, DonorAsBytes)                    //store owner by its Id
		if err != nil {
			fmt.Println("Could not store Donor")
			return shim.Error(err.Error())
		}

		NpoAsBytes, _ := json.Marshal(temp_npo)
		fmt.Println("writing Npo information to ledger")
		fmt.Println(string(NpoAsBytes))

		err = stub.PutState(temp_npo.Id, NpoAsBytes)                    //store owner by its Id
		if err != nil {
			fmt.Println("Could not store Npo")
			return shim.Error(err.Error())
		}

	}

	return shim.Success(nil)
}

func (t *SimpleChaincode) delete_asset(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var err error

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	var temp_asset Asset
	temp_asset_by_byte, err := stub.GetState(args[0])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get Asset state \"}"
		return shim.Error(jsonResp)
	}
	json.Unmarshal(temp_asset_by_byte, &temp_asset)

	if temp_asset.NPOId != args[1]{
		jsonResp := "{\"Error\":\"Asset is not owned by given NPO\"}"
		return shim.Error(jsonResp)
	}

	err = stub.DelState(temp_asset.Id)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store Asset")
		return shim.Error(err.Error())
	}

	var temp_npo NPO
	temp_npo_by_byte, err := stub.GetState(args[0])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get Npo state \"}"
		return shim.Error(jsonResp)
	}
	json.Unmarshal(temp_npo_by_byte, &temp_npo)

	fmt.Println(temp_npo)
	for i, v := range temp_npo.Assets_array {
		if v == temp_asset.Id {
			temp_npo.Assets_array = append(temp_npo.Assets_array[:i], temp_npo.Assets_array[i+1:]...)
			break
		}
	}
	fmt.Println(temp_npo)

	NpoAsBytes, _ := json.Marshal(temp_npo)
	fmt.Println("writing NPO information to ledger")
	fmt.Println(string(NpoAsBytes))

	err = stub.PutState(temp_npo.Id, NpoAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store NPO")
		return shim.Error(err.Error())
	}

	var temp_donor Donor
	temp_donor_by_byte, err := stub.GetState(temp_asset.DonorId)
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get Donor state for \"}"
		return shim.Error(jsonResp)
	}
	json.Unmarshal(temp_donor_by_byte, &temp_donor)

	fmt.Println(temp_donor)
	for i, v := range temp_donor.Assets_array {
		if v == temp_asset.Id {
			temp_donor.Assets_array = append(temp_donor.Assets_array[:i], temp_donor.Assets_array[i+1:]...)
			break
		}
	}
	fmt.Println(temp_donor)

	DonorAsBytes, _ := json.Marshal(temp_donor)
	fmt.Println("writing Donor information to ledger")
	fmt.Println(string(DonorAsBytes))

	err = stub.PutState(temp_donor.Id, DonorAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store Donor")
		return shim.Error(err.Error())
	}

	return shim.Success(nil)
}

func (t *SimpleChaincode) borrow_asset(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var err error

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}


	var temp_asset Asset
	temp_asset_by_byte, err := stub.GetState(args[0])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get asset state\"}"
		return shim.Error(jsonResp)
	}

	if temp_asset_by_byte == nil {
		jsonResp := "{\"Error\":\"Nil amount asset state\"}"
		return shim.Error(jsonResp)
	}

	json.Unmarshal(temp_asset_by_byte, &temp_asset)

	var temp_rec Recipient
	temp_rec_by_byte, err := stub.GetState(args[1])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get rec state for \"}"
		return shim.Error(jsonResp)
	}

	if temp_asset_by_byte == nil {
		jsonResp := "{\"Error\":\"Nil amount rec information \"}"
		return shim.Error(jsonResp)
	}

	json.Unmarshal(temp_rec_by_byte, &temp_rec)
	temp_rec.Asset_array = append(temp_rec.Asset_array, temp_asset.Id)


	var temp_owner_relation OwnerRelation
	temp_owner_relation.Id = temp_rec.Id
	temp_owner_relation.Username = temp_rec.Name
	temp_owner_relation.User_type= temp_rec.Types
	fmt.Println(temp_owner_relation)

	temp_asset.Owner_history = append(temp_asset.Owner_history, temp_owner_relation)
	temp_asset.Status = "B"

	AssetAsBytes, _ := json.Marshal(temp_asset)
	fmt.Println("writing Asset information to ledger")
	fmt.Println(string(AssetAsBytes))

	err = stub.PutState(temp_asset.Id, AssetAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store Asset")
		return shim.Error(err.Error())
	}

	RecAsBytes, _ := json.Marshal(temp_rec)
	fmt.Println("writing Rec information to ledger")
	fmt.Println(string(RecAsBytes))

	err = stub.PutState(temp_rec.Id, RecAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store Rec")
		return shim.Error(err.Error())
	}

	return shim.Success(nil)
}

func (t *SimpleChaincode) give_asset(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var err error

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}


	var temp_asset Asset
	temp_asset_by_byte, err := stub.GetState(args[0])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get asset state\"}"
		return shim.Error(jsonResp)
	}

	if temp_asset_by_byte == nil {
		jsonResp := "{\"Error\":\"Nil amount asset state\"}"
		return shim.Error(jsonResp)
	}

	json.Unmarshal(temp_asset_by_byte, &temp_asset)

	var temp_rec Recipient
	temp_rec_by_byte, err := stub.GetState(args[1])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get rec state for \"}"
		return shim.Error(jsonResp)
	}

	if temp_asset_by_byte == nil {
		jsonResp := "{\"Error\":\"Nil amount rec information \"}"
		return shim.Error(jsonResp)
	}

	json.Unmarshal(temp_rec_by_byte, &temp_rec)
	temp_rec.Asset_array = append(temp_rec.Asset_array, temp_asset.Id)


	var temp_owner_relation OwnerRelation
	temp_owner_relation.Id = temp_rec.Id
	temp_owner_relation.Username = temp_rec.Name
	temp_owner_relation.User_type= temp_rec.Types
	fmt.Println(temp_owner_relation)

	temp_asset.Owner_history = append(temp_asset.Owner_history, temp_owner_relation)
	temp_asset.Status = "G"

	AssetAsBytes, _ := json.Marshal(temp_asset)
	fmt.Println("writing Asset information to ledger")
	fmt.Println(string(AssetAsBytes))

	err = stub.PutState(temp_asset.Id, AssetAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store Asset")
		return shim.Error(err.Error())
	}

	RecAsBytes, _ := json.Marshal(temp_rec)
	fmt.Println("writing Rec information to ledger")
	fmt.Println(string(RecAsBytes))

	err = stub.PutState(temp_rec.Id, RecAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store Rec")
		return shim.Error(err.Error())
	}

	return shim.Success(nil)
}

func (t *SimpleChaincode) get_back_asset(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	var err error

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 5")
	}


	var temp_asset Asset
	temp_asset_by_byte, err := stub.GetState(args[0])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get asset state for\"}"
		return shim.Error(jsonResp)
	}

	if temp_asset_by_byte == nil {
		jsonResp := "{\"Error\":\"Nil amount asset state \"}"
		return shim.Error(jsonResp)
	}

	json.Unmarshal(temp_asset_by_byte, &temp_asset)

	var temp_rec Recipient
	temp_rec_by_byte, err := stub.GetState(args[1])
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get rec state \"}"
		return shim.Error(jsonResp)
	}

	if temp_asset_by_byte == nil {
		jsonResp := "{\"Error\":\"Nil amount rec state\"}"
		return shim.Error(jsonResp)
	}

	json.Unmarshal(temp_rec_by_byte, &temp_rec)



	temp_asset.Status = "A"
	for i, v := range temp_rec.Asset_array {
		if v == temp_asset.Id {
			temp_rec.Asset_array = append(temp_rec.Asset_array[:i], temp_rec.Asset_array[i+1:]...)
			break
		}
	}

	AssetAsBytes, _ := json.Marshal(temp_asset)
	fmt.Println("writing Asset information to ledger")
	fmt.Println(string(AssetAsBytes))

	err = stub.PutState(temp_asset.Id, AssetAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store Asset")
		return shim.Error(err.Error())
	}

	RecAsBytes, _ := json.Marshal(temp_rec)
	fmt.Println("writing Rec information to ledger")
	fmt.Println(string(RecAsBytes))

	err = stub.PutState(temp_rec.Id, RecAsBytes)                    //store owner by its Id
	if err != nil {
		fmt.Println("Could not store Rec")
		return shim.Error(err.Error())
	}

	return shim.Success(nil)
}

// ============================================================================================================================
// Query - General_query_function (needed to be specify)
// ============================================================================================================================
func (t *SimpleChaincode) query(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var A string // Entities
	var err error

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting name of the person to query")
	}

	A = args[0]

	// Get the state from the ledger
	Avalbytes, err := stub.GetState(A)
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get state for " + A + "\"}"
		return shim.Error(jsonResp)
	}

	if Avalbytes == nil {
		jsonResp := "{\"Error\":\"Nil amount for " + A + "\"}"
		return shim.Error(jsonResp)
	}

	jsonResp := "{\"Name\":\"" + A + "\",\"Amount\":\"" + string(Avalbytes) + "\"}"
	fmt.Printf("Query Response:%s\n", jsonResp)
	return shim.Success(Avalbytes)
}

